# Binary Search üìö
The binary search algorithm is an example of a divide-and-conquer algorithm. 

Divide-and-conquer is problem solving technique which works by repeatedly reducing the problem _(divide)_ and then attempting to solve the problem _(conquer)_ on the new problem space. In this case the approach is to repeatedly divide the portion of the list that could contain the item in two _(i.e. half)_, until either the item is found or the list cannot be divided any further.

## Watch this video on Binary Search üì∫
[CS50 Phone Book Example](https://www.youtube.com/watch?v=DSffdCT5Cx4)

In computer science, **Binary Search**, also known as _half-interval search, logarithmic search, or binary chop,_ is a search algorithm that finds the position of a target value within a **sorted list _(array)_**. Binary search compares the target value to the middle element of the array.

- Instead of testing the list's first element, the binary search starts with the element in the middle.
- If that element happens to contain the target value, then the search is over.
- If the target value is less than the middle element of the list, we restrict the search to the first half of the list; otherwise we search the second half of the list.
- Either way, half of the list‚Äôs elements are eliminated from further searching on each iteration and the procedure is repeated for the half of the list that potentially contains the value.

This process continues until the value being searched for is either found, or there are no more elements to test.



### Pseudo-Code üìù
The pseudo-code for the binary search algorithm is as follows:
````
1. Set low = 0
2. Set high = length of list ‚Äì 1
3. Set mid = (low+high)/2, rounded down to an integer
4.  If the value at the mid position is the same as the target value
      Return mid
    Else If the value at the mid position is less than the target value
      Set low = mid + 1
    Else If the value at the mid position is greater than the target value
      Set high = mid - 1
5. As long as low doesn‚Äôt ‚Äòcross over‚Äô high, go back to step 3 above 6. Return -1
````
Let‚Äôs say we were tasked with applying the above algorithm to search for a target value of **``28``** in the following list of 16 values. 

üí°**Note:** The index numbers from 0‚Ä¶15 are displayed over each list element and, crucially, that **the list has already been sorted.**

![image](https://github.com/ross-bish/Algorithms/assets/83789503/7da6c190-f108-495a-824d-4ef983778636)

- In the first three steps of the algorithm we set the variables ``low = 0``, ``high = 15`` and ``mid = 7``.

![image](https://github.com/ross-bish/Algorithms/assets/83789503/587de46c-6567-4603-b421-ef6823334b60)

- We now move to _line 4_ of the algorithm and since ``14`` is less than ``28`` we change the value of ``low`` to ``mid+1`` which is ``8``. 

- The value of ``mid`` is **now** computed to be ``(8+15)/2`` which is ``11`` **(rounded down)**.
- Our state now look like this:

![image](https://github.com/ross-bish/Algorithms/assets/83789503/0ab92e37-b6a4-47e7-94b3-88169fca50bc)

- Since ``25`` is less than ``28`` we change the value of ``low`` again, this time to ``12``.
- The new value for ``mid`` becomes ``13`` and the state can be visualised as follows:

![image](https://github.com/ross-bish/Algorithms/assets/83789503/7686a769-a8c2-4901-82de-6dd571c07066)

Since the next comparison finds the target value, the algorithm can terminate successfully. üòé

### Trace Tables 
The use of _trace tables_ can be very helpful in carrying out a binary search. 

A trace table for this example might look as follows:

| low | mid | high| 







