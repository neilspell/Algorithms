# Insertion Sort ðŸ“š

Insertion sort is a basic sorting algorithm that builds the final sorted array one element at a time. 

It iterates over the input list, removing one element per iteration and inserting it into the correct position in the **sorted** part of the list.

Here's how insertion sort works:

1. **Start:** Begin with the second element of the list (assuming the first element is already sorted).
2. **Insertion:** Iterate over the unsorted part of the list, removing one element per iteration and inserting it into the correct position in the sorted part of the list.
3. **Repeat:** Repeat step 2 until the entire list is sorted.


### Example of Insertion Sort in Python:

```python
def insertion_sort(myList):
    for i in range(1, len(myList)):
        current_element = myList[i]  # Store the current element being considered
        j = i - 1  # Start comparing with the element just before the current element

        # Move elements of myList[0..i-1], that are greater than current_element, one position ahead of their current position
        while j >= 0 and myList[j] > current_element:
            myList[j + 1] = myList[j]
            j -= 1
        
        # Insert the current_element into the correct position
        myList[j + 1] = current_element

# Example usage:
numbers = [64, 34, 25, 12, 22, 11, 90]
insertion_sort(numbers)
print("Sorted array:", numbers)

```

This will output the sorted array `[11, 12, 22, 25, 34, 64, 90]`.

### Explanation:
Let's break down the insertion sort algorithm step by step:

1. **For Loop**: 
   - We start by iterating over the list `myList` starting from the second element (`i` starts from 1) and going up to the last element. This loop allows us to consider each element one by one.

2. **Current Element Assignment**:
   - Inside the loop, we store the current element being considered in a variable `current_element`. This element will be compared and inserted into its correct position in the sorted part of the list.

3. **Backward Comparison Loop**:
   - We initialize a variable `j` to `i - 1`, which points to the element just before the current element being considered (`current_element`).
   - We enter a while loop that continues until `j` is greater than or equal to `0` (ensuring we don't go out of bounds) and the element at position `j` is greater than `current_element`.
   - Inside the while loop, we shift elements to the right (`myList[j + 1] = myList[j]`) to make space for `current_element`.
   - We decrement `j` by `1` to move backward through the sorted portion of the list.

4. **Insertion of Current Element**:
   - Once the while loop exits, we have found the correct position for `current_element` in the sorted part of the list.
   - We insert `current_element` into its correct position by assigning it to `myList[j + 1]`.

5. **Repeat**:
   - We repeat steps 2-4 for each element in the list, gradually building the sorted array one element at a time.

This simplified version follows the same core logic as the original insertion sort algorithm but uses more descriptive variable names and comments to make it easier to understand for beginners. It's a great starting point for learning about sorting algorithms!


### ðŸ’¡Note:
- In insertion sort, we start with the second element of the list `myList[1]` and compare it with the elements to its left `myList[0]`. We then insert the current element `myList[i]` into its correct position among the sorted elements to its _**left.**_
- We repeat this process for each element in the list, gradually building the sorted array one element at a time.
- The time complexity of insertion sort is ``O(nÂ²)`` in the worst case, making it suitable for small lists or partially sorted lists.
