# Insertion Sort ðŸ“š

Insertion sort is a basic sorting algorithm that builds the final sorted array one element at a time. 

It iterates over the input list, removing one element per iteration and inserting it into the correct position in the **sorted** part of the list.

Here's how insertion sort works:

1. **Start:** Begin with the second element of the list (assuming the first element is already sorted).
2. **Insertion:** Iterate over the unsorted part of the list, removing one element per iteration and inserting it into the correct position in the sorted part of the list.
3. **Repeat:** Repeat step 2 until the entire list is sorted.


### Example of Insertion Sort in Python:

```python
def insertion_sort(myList):
    for i in range(1, len(myList)):
        current_element = myList[i]  # Store the current element being considered
        j = i - 1  # Start comparing with the element just before the current element

        # Move elements of myList[0..i-1], that are greater than current_element, one position ahead of their current position
        while j >= 0 and myList[j] > current_element:
            myList[j + 1] = myList[j]
            j -= 1
        
        # Insert the current_element into the correct position
        myList[j + 1] = current_element

# Example usage:
numbers = [64, 34, 25, 12, 22, 11, 90]
insertion_sort(numbers)
print("Sorted array:", numbers)

```

This will output the sorted array `[11, 12, 22, 25, 34, 64, 90]`.

### Explanation:

- In insertion sort, we start with the second element of the list (`myList[1]`) and compare it with the elements to its left (`myList[0]`, `myList[1]`, ..., `myList[i-1]`). We then insert the current element (`myList[i]`) into its correct position among the sorted elements to its left.
- We repeat this process for each element in the list, gradually building the sorted array one element at a time.
- The time complexity of insertion sort is \(O(n^2)\) in the worst case, making it suitable for small lists or partially sorted lists.
